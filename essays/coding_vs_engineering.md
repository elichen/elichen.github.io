# Why AI Makes Coding Free But Engineering More Valuable

## The Core Thesis

AI is making the cost of coding drop rapidly toward zero, and the effort required approaching nothing. This transformation is happening faster than most people realize. Looking back over my last two years, coding a software project has compressed from two weeks to two days to two hours—driven by both its increasing coding skill and AI's expanding agentic capabilities for long-horizon tasks.

This document explores why this shift doesn't diminish the role of software engineers, but rather elevates the most critical aspects of their craft.

## What Coding Actually Entails

Coding has traditionally required deep fluency in multiple layers of technical knowledge:

**Syntax and Language Mastery**: Understanding programming languages at a fundamental level, similar to learning a musical instrument. This knowledge had to be internalized through textbooks, exercises, and countless hours of practice.

**Ecosystem Expertise**: Mastering libraries, frameworks, and language-specific tools. Productive engineers needed "muscle memory" across these systems because referencing documentation mid-build was ineffective for production code.

**Best Practices and Patterns**: Learning not just what works, but what works well—understanding gotchas, anti-patterns, and proven approaches that prevent future problems.

**Cultural Knowledge**: Absorbing coding idioms, internal style guides, and community conventions. Code doesn't exist in isolation; it must pass review by other engineers through processes like pull requests.

This learning curve is substantial. At companies like Twitter, engineers typically spent six months ramping up—learning Scala, understanding distributed systems infrastructure, and internalizing internal style guides before becoming truly productive.

## Where Human Judgment Remains Critical

Beyond coding lies software engineering: the art of making decisions that determine a system's fundamental characteristics. These decisions shape performance, quality, security, and scalability in ways that either enable or constrain everything built on top.

**Examples of Engineering Decisions**:
- Hash map versus linked list
- Schema versus unstructured data
- SQL versus NoSQL databases  
- Strict event ordering versus unordered processing
- SSO versus magic link authentication
- Frontend framework selection
- Mutable versus immutable programming paradigms

These choices have cascading consequences. Selecting the wrong database leads to scaling failures—causing outages when systems can't handle growth or requiring expensive infrastructure to compensate. Poor authentication decisions create security vulnerabilities or block enterprise sales due to compliance issues.

Conversely, excellent engineering decisions create tangible user value. Apple's obsessive attention to performance engineering delivers the high frame rates that make their devices feel responsive and delightful. These aren't coding problems—they're architectural and systems thinking problems.

## The Historical Conflation

Traditionally, software engineering education and careers have bundled coding and engineering together. Computer science programs teach algorithms alongside syntax, and job descriptions blur the lines between implementation and design. This made sense when coding itself required such significant human investment that the two skills developed together naturally.

But AI is severing this connection. As coding becomes free, bundling is no longer required.

## The Elevation of Engineering

This unbundling doesn't deprecate software engineers—it elevates them. When coding friction disappears, engineers can dedicate more attention to the decisions that truly matter: those that determine whether systems scale gracefully, whether security holds under pressure, whether users find products delightful rather than frustrating.

Engineering is a craft with deep historical roots in human problem-solving, tracing back millennia to ancient achievements like Egyptian pyramids and Roman aqueducts. In contrast, computer science emerged as an academic discipline only in the 1950s-60s, making it roughly 70 years old. The bundling of coding skills with engineering judgment happened during computer science's rapid formation, when both were necessary. But this historical pairing was circumstantial, not fundamental.

Engineering is about understanding available tools, recognizing constraints, making tradeoffs, and pushing the boundaries of what's possible. These decisions require something that remains uniquely human: empathy. Understanding user needs, anticipating system failures, and balancing competing priorities all draw on human intuition and experience.

Engineering also drives the research that creates better tools. The feedback loop between building systems and improving the foundational technologies that make those systems possible requires human creativity and insight.

## The Future Distinction

This is why coding is becoming free, but software engineering is becoming ever more important. As AI handles the mechanical aspects of implementation, the premium on good judgment, systems thinking, and human empathy increases. The engineers who recognize this shift and develop these higher-level skills will find themselves more valuable, not less.

The craft of engineering—solving complex problems with elegant solutions, creating systems that serve human needs, and pushing the boundaries of what technology can accomplish—remains fundamentally human. AI may write the code, but humans must still decide what to build and how it should work.

Ultimately, I believe humans will always have the advantage in human empathy when we're building human products. Understanding pain points, anticipating needs, and creating experiences that truly resonate with users requires the kind of lived experience and emotional intelligence that remains uniquely human. As we build technology to serve people, this human understanding becomes not just valuable—it becomes irreplaceable.
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ant - Sphere Surface IK</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { width: 100%; height: 100vh; display: block; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
<script>
// Ant walking with 2-bone IK on a sphere

const COXA_LENGTH = 0.06;
const FEMUR_LENGTH = 0.12;
const TIBIA_LENGTH = 0.18;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0e13);
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(1.2, 0.6, 1.2);
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('c'), antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

scene.add(new THREE.AmbientLight(0x4a4a4a));
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(2,3,2);
dir.castShadow = true;
scene.add(dir);

// Define sphere parameters
const SPHERE_RADIUS = 2.0; // Sphere radius
const SPHERE_CENTER = new THREE.Vector3(0, -SPHERE_RADIUS * 0.7, 0); // Center lowered so ant starts near top

// Log the sphere parameters
console.log('Sphere radius:', SPHERE_RADIUS);
console.log('Sphere center:', SPHERE_CENTER);

// Helper function to get point on sphere surface given x,z coordinates
// Projects (x,z) onto sphere and returns the y coordinate on upper hemisphere
function getSurfacePoint(x, z) {
  // Vector from sphere center to (x, ?, z)
  const dx = x - SPHERE_CENTER.x;
  const dz = z - SPHERE_CENTER.z;
  const distSq = dx * dx + dz * dz;
  
  // If outside sphere radius in XZ plane, clamp to sphere
  const maxDistSq = SPHERE_RADIUS * SPHERE_RADIUS;
  if (distSq > maxDistSq) {
    // Point is outside sphere projection, return undefined or clamp
    const scale = Math.sqrt(maxDistSq / distSq);
    const clampedX = SPHERE_CENTER.x + dx * scale;
    const clampedZ = SPHERE_CENTER.z + dz * scale;
    return SPHERE_CENTER.y + SPHERE_RADIUS; // Top of sphere
  }
  
  // Calculate y on sphere surface (upper hemisphere)
  const y = Math.sqrt(SPHERE_RADIUS * SPHERE_RADIUS - distSq);
  return SPHERE_CENTER.y + y;
}

// Helper to get surface normal at a point on sphere
function getSurfaceNormal(x, z) {
  const y = getSurfacePoint(x, z);
  
  // Normal points from center to surface point
  const normal = new THREE.Vector3(
    x - SPHERE_CENTER.x,
    y - SPHERE_CENTER.y,
    z - SPHERE_CENTER.z
  ).normalize();
  
  return normal;
}

// Create rotation quaternion to align Y-up to surface normal at origin
const planeQuat = new THREE.Quaternion();
const up = new THREE.Vector3(0, 1, 0);
const avgNormal = getSurfaceNormal(0, 0);
planeQuat.setFromUnitVectors(up, avgNormal);

// Create sphere mesh
const groundMat = new THREE.MeshStandardMaterial({ 
  color: 0x404040, 
  roughness: 0.8, 
  metalness: 0.1,
  side: THREE.DoubleSide 
});

// Create sphere geometry
const sphereGeometry = new THREE.SphereGeometry(SPHERE_RADIUS, 60, 40);
const sphere = new THREE.Mesh(sphereGeometry, groundMat);
sphere.position.copy(SPHERE_CENTER);
sphere.receiveShadow = true;
sphere.castShadow = true;
scene.add(sphere);

// Add wireframe overlay for better visualization
const wireframeMat = new THREE.MeshBasicMaterial({ 
  color: 0x334455, 
  wireframe: true,
  transparent: true,
  opacity: 0.2
});
const wireframe = new THREE.Mesh(sphereGeometry, wireframeMat);
wireframe.position.copy(SPHERE_CENTER);
scene.add(wireframe);

// Add equator line for reference
const equatorGeometry = new THREE.BufferGeometry();
const equatorPoints = [];
const divisions = 64;
for (let i = 0; i <= divisions; i++) {
  const angle = (i / divisions) * Math.PI * 2;
  equatorPoints.push(
    SPHERE_CENTER.x + SPHERE_RADIUS * Math.cos(angle),
    SPHERE_CENTER.y,
    SPHERE_CENTER.z + SPHERE_RADIUS * Math.sin(angle)
  );
}
equatorGeometry.setAttribute('position', new THREE.Float32BufferAttribute(equatorPoints, 3));
const equatorMat = new THREE.LineBasicMaterial({ color: 0x667788 });
const equator = new THREE.Line(equatorGeometry, equatorMat);
scene.add(equator);

const axes = new THREE.AxesHelper(0.3);
scene.add(axes);

function createAnt() {
  const antGroup = new THREE.Group();
  const bodyMat = new THREE.MeshPhongMaterial({ color: 0x7A4426, shininess: 40 });
  const legMat = new THREE.MeshPhongMaterial({ color: 0x5C3317, shininess: 20 });

  // Body
  const thorax = new THREE.Mesh(new THREE.SphereGeometry(0.08, 20, 16), bodyMat);
  thorax.scale.set(1, 0.8, 1.2);
  thorax.castShadow = true;
  antGroup.add(thorax);

  const abdomen = new THREE.Mesh(new THREE.SphereGeometry(0.1, 20, 16), bodyMat);
  abdomen.scale.set(1, 0.8, 1.4);
  abdomen.position.set(0, 0, -0.2);
  abdomen.castShadow = true;
  antGroup.add(abdomen);

  const head = new THREE.Mesh(new THREE.SphereGeometry(0.06, 16, 12), bodyMat);
  head.position.set(0, 0, 0.15);
  head.castShadow = true;
  antGroup.add(head);

  // Antennae (base pivot so attachment stays correct)
  const antennaLength = 0.15;
  const antennaGeom = new THREE.CylinderGeometry(0.002, 0.005, antennaLength, 8);
  const antennaMat = new THREE.MeshPhongMaterial({ color: 0x5C3317 });
  for (let i=0;i<2;i++) {
    const side = i===0 ? -1 : 1; // -1 = left, +1 = right
    const root = new THREE.Group();
    root.position.set(side*0.03, 0.02, 0.055);
    root.rotation.x = Math.PI/3;        // tilt forward (+Z)
    root.rotation.z = -side*Math.PI/6;  // splay outward
    head.add(root);

    const ant = new THREE.Mesh(antennaGeom, antennaMat);
    ant.castShadow = true;
    ant.position.y = antennaLength/2;   // extend from base
    root.add(ant);
  }

  // Leg rig (consistent axes):
  // - legRoot: yaw around Y
  // - coxaPivot: fixed outward splay around Y
  // - femurPivot: rotate around Z in XY plane
  // - tibiaPivot: rotate around Z in XY plane
  const legs = [];
  const legPositions = [
    [ 0.06, 0.00,  0.05,  1],
    [ 0.06, 0.00,  0.00,  1],
    [ 0.06, 0.00, -0.05,  1],
    [-0.06, 0.00,  0.05, -1],
    [-0.06, 0.00,  0.00, -1],
    [-0.06, 0.00, -0.05, -1],
  ];

  legPositions.forEach((p, index) => {
    const [px, py, pz, side] = p;

    const legRoot = new THREE.Group();
    legRoot.position.set(px, py, pz);
    thorax.add(legRoot);

    const coxaPivot = new THREE.Group();
    // Orient by row: front forward, middle sideways, rear backward with slight outward splay
    const splayMag = Math.PI/8;
    const isFront = pz > 0.001;
    const isBack  = pz < -0.001;
    let baseYaw;
    if (isFront) {
      baseYaw = -Math.PI/2 + side * splayMag; // face +Z
    } else if (isBack) {
      baseYaw =  Math.PI/2 - side * splayMag; // face -Z
    } else {
      baseYaw = side > 0 ? 0 : Math.PI;       // sideways outward
    }
    coxaPivot.rotation.y = baseYaw;
    legRoot.add(coxaPivot);

    const coxa = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.010, COXA_LENGTH, 8), legMat);
    coxa.rotation.z = -Math.PI/2; // along +X
    coxa.position.x = COXA_LENGTH/2;
    coxa.castShadow = true;
    coxaPivot.add(coxa);

    const femurPivot = new THREE.Group();
    femurPivot.position.x = COXA_LENGTH;
    coxaPivot.add(femurPivot);

    const femur = new THREE.Mesh(new THREE.CylinderGeometry(0.009, 0.007, FEMUR_LENGTH, 8), legMat);
    femur.rotation.z = -Math.PI/2; // along +X
    femur.position.x = FEMUR_LENGTH/2;
    femur.castShadow = true;
    femurPivot.add(femur);

    const tibiaPivot = new THREE.Group();
    tibiaPivot.position.x = FEMUR_LENGTH;
    femurPivot.add(tibiaPivot);

    const tibia = new THREE.Mesh(new THREE.CylinderGeometry(0.007, 0.004, TIBIA_LENGTH, 8), legMat);
    tibia.rotation.z = -Math.PI/2; // along +X
    tibia.position.x = TIBIA_LENGTH/2;
    tibia.castShadow = true;
    tibiaPivot.add(tibia);

    // Neutral, comfortable pose to match static model
    femurPivot.rotation.z = -0.9;
    tibiaPivot.rotation.z = 0.8;

    legs.push({ index, side, legRoot, coxaPivot, femurPivot, tibiaPivot });
  });

  return { antGroup, thorax, legs };
}

const { antGroup, thorax, legs } = createAnt();
scene.add(antGroup);

// Body placement calibrated to neutral pose: foot tips touch the ground
const FEMUR_NEUTRAL = -0.9;
const TIBIA_NEUTRAL = 0.8;
// Calculate clearance for sphere surface - needs to account for leg reach
// The original calculation was for flat ground
const FEMUR_ANGLE_NEUTRAL = -0.9;
const TIBIA_ANGLE_NEUTRAL = 0.8;
const CLEARANCE_FLAT = -(FEMUR_LENGTH*Math.sin(FEMUR_ANGLE_NEUTRAL) + TIBIA_LENGTH*Math.sin(FEMUR_ANGLE_NEUTRAL + TIBIA_ANGLE_NEUTRAL));

// For sphere surface, we need less clearance since we're positioning along the normal
// Use the flat ground clearance as a starting point
const CLEARANCE = CLEARANCE_FLAT;

console.log('Leg dimensions:');
console.log('  COXA_LENGTH:', COXA_LENGTH);
console.log('  FEMUR_LENGTH:', FEMUR_LENGTH);
console.log('  TIBIA_LENGTH:', TIBIA_LENGTH);
console.log('  Total reach:', COXA_LENGTH + FEMUR_LENGTH + TIBIA_LENGTH);
console.log('  Calculated CLEARANCE:', CLEARANCE);

// Orient ant body to match sphere surface at starting position
// Start at a point on the sphere
const initialTheta = 0;
const pathRadius = SPHERE_RADIUS * 0.8;
const initialX = pathRadius * Math.sin(initialTheta);
const initialZ = pathRadius * Math.cos(initialTheta);
const surfaceY = getSurfacePoint(initialX, initialZ);
const surfaceNormal = getSurfaceNormal(initialX, initialZ);

// Position ant at the correct height above sphere surface
// We want the ant's belly to be CLEARANCE distance from the sphere surface
// Since we're on a sphere, we position the ant at radius = SPHERE_RADIUS + CLEARANCE from center
const antRadius = SPHERE_RADIUS + CLEARANCE;
const antPosOnSphere = new THREE.Vector3(
  initialX - SPHERE_CENTER.x,
  surfaceY - SPHERE_CENTER.y,
  initialZ - SPHERE_CENTER.z
).normalize().multiplyScalar(antRadius);

antGroup.position.set(
  SPHERE_CENTER.x + antPosOnSphere.x,
  SPHERE_CENTER.y + antPosOnSphere.y,
  SPHERE_CENTER.z + antPosOnSphere.z
);

// Align ant to surface normal and face along path
// First align Y-axis with surface normal
const antUp = new THREE.Vector3(0, 1, 0);
const surfaceQuat = new THREE.Quaternion();
surfaceQuat.setFromUnitVectors(antUp, surfaceNormal);

// At theta=0, ant is at (0, y, +z) and will move in -X direction
// So it should face -X (left)
const headingAngle = Math.PI/2; // Face -X direction
const headingQuat = new THREE.Quaternion();
headingQuat.setFromAxisAngle(surfaceNormal, headingAngle);

// Combine: first align to surface, then rotate to face movement direction
const finalQuat = new THREE.Quaternion();
finalQuat.multiplyQuaternions(headingQuat, surfaceQuat);
antGroup.setRotationFromQuaternion(finalQuat);

// Debug logging
console.log('Initial ant position:', antGroup.position);
console.log('Initial surface point:', { x: initialX, y: surfaceY, z: initialZ });
console.log('Initial surface normal:', surfaceNormal);
console.log('Clearance:', CLEARANCE);
console.log('Ant rotation (euler):', antGroup.rotation);
console.log('Ant quaternion:', antGroup.quaternion);

// Calculate and log distance from ant belly to sphere surface
const antBellyWorld = antGroup.position.clone();
const distanceToSphereCenter = antBellyWorld.distanceTo(SPHERE_CENTER);
const distanceToSphereSurface = distanceToSphereCenter - SPHERE_RADIUS;
console.log('=== Ant-to-Sphere Distance ===');
console.log('Ant belly position (world):', antBellyWorld);
console.log('Distance to sphere center:', distanceToSphereCenter);
console.log('Distance to sphere surface:', distanceToSphereSurface);
console.log('Expected clearance:', CLEARANCE);
console.log('Difference (actual - expected):', distanceToSphereSurface - CLEARANCE);

// Tripod gait
const tripodA = new Set([0,2,4]);
const period = 2.4; // seconds for full cycle

// IMPORTANT: Update world matrices after setting rotation
antGroup.updateMatrixWorld(true);
thorax.updateMatrixWorld(true);

// Home offsets in thorax space for foot targets computed from the neutral FK
// This MUST be calculated AFTER the ant is rotated to match the surface
const home = (() => {
  thorax.updateMatrixWorld(true);
  const worldToThoraxMat = new THREE.Matrix4().copy(thorax.matrixWorld).invert();
  return legs.map((leg) => {
    // get tibia tip in world at current neutral rotations
    const tipLocal = new THREE.Vector3(TIBIA_LENGTH, 0, 0);
    const tipWorld = tipLocal.clone();
    leg.tibiaPivot.localToWorld(tipWorld);

    // For home positions, we want feet to naturally rest on the sphere
    // Don't force projection here, let IK handle reaching the surface
    // Just convert to thorax local space
    return tipWorld.applyMatrix4(worldToThoraxMat);
  });
})();

// Helpers
const worldToThorax = new THREE.Matrix4();
const Y = new THREE.Vector3(0,1,0);
const tmp = {
  targetWorld: new THREE.Vector3(),
  targetThorax: new THREE.Vector3(),
  relFromRoot: new THREE.Vector3(),
  yawQuat: new THREE.Quaternion(),
  tempQuat: new THREE.Quaternion(),
  pA: new THREE.Vector3(), pB: new THREE.Vector3(),
};

// Debug markers
const footMarkers = [];
for (let i=0;i<legs.length;i++) {
  const s = new THREE.Mesh(new THREE.SphereGeometry(0.01, 10, 8), new THREE.MeshBasicMaterial({ color: tripodA.has(i)?0x33ffaa:0xffaa33 }));
  scene.add(s);
  footMarkers.push(s);
}

// IK solver in XY plane (after yaw unrotation and coxa splay removal)
function solvePlanarIK(x, y) {
  const L1 = FEMUR_LENGTH, L2 = TIBIA_LENGTH;
  const D = Math.max(1e-6, Math.min(L1 + L2 - 1e-4, Math.hypot(x, y)));
  const cosKnee = THREE.MathUtils.clamp((L1*L1 + L2*L2 - D*D) / (2*L1*L2), -1, 1);
  // Mechanical knee rotation (0 straight → pi folded); matches our rig's tibiaPivot rotation
  const knee = Math.PI - Math.acos(cosKnee);
  const femur = Math.atan2(y, x) - Math.atan2(L2 * Math.sin(knee), L1 + L2 * Math.cos(knee));
  return { femur, tibia: knee };
}

// State per leg
const state = legs.map((leg, i) => ({
  planted: new THREE.Vector3(),
  current: new THREE.Vector3(),
  initialized: false,
  inStancePrev: false,
}));

const STEP_HEIGHT = 0.04;
const STEP_LENGTH = 0.08;
const FOOT_OFFSET = 0.0; // exact ground contact in stance
const bodySpeed = 0.04; // slower forward for inspection

const LOG_WALK = true;
const LOG_EVERY = 20;
let FRAME_NO = 0;

let t0 = performance.now() / 1000;

function animate() {
  requestAnimationFrame(animate);
  FRAME_NO++;
  const t = performance.now()/1000 - t0; // Enable animation

  // Move body around the sphere in a circular path
  // Use spherical coordinates for movement
  const angularSpeed = bodySpeed / SPHERE_RADIUS; // Convert linear to angular speed
  const theta = t * angularSpeed; // Angle around sphere

  // Path around sphere at constant latitude (near top)
  const pathRadius = SPHERE_RADIUS * 0.8; // Circle radius on sphere
  const bodyX = pathRadius * Math.sin(theta);
  const bodyZ = pathRadius * Math.cos(theta);

  const surfaceY = getSurfacePoint(bodyX, bodyZ);
  const surfaceNormal = getSurfaceNormal(bodyX, bodyZ);

  // Position ant at the correct height above sphere surface
  // The ant should be at radius = SPHERE_RADIUS + CLEARANCE from center
  const antRadius = SPHERE_RADIUS + CLEARANCE;
  const antPosOnSphere = new THREE.Vector3(
    bodyX - SPHERE_CENTER.x,
    surfaceY - SPHERE_CENTER.y,
    bodyZ - SPHERE_CENTER.z
  ).normalize().multiplyScalar(antRadius);

  antGroup.position.set(
    SPHERE_CENTER.x + antPosOnSphere.x,
    SPHERE_CENTER.y + antPosOnSphere.y,
    SPHERE_CENTER.z + antPosOnSphere.z
  );
  
  // Maintain orientation: aligned to surface normal
  // For now, just align Y-axis with surface normal
  const antUp = new THREE.Vector3(0, 1, 0);
  const surfaceQuat = new THREE.Quaternion();
  surfaceQuat.setFromUnitVectors(antUp, surfaceNormal);
  
  // Add rotation to face along the circular path
  const headingAngle = theta + Math.PI/2; // Perpendicular to radius = tangent to circle
  const headingQuat = new THREE.Quaternion();
  headingQuat.setFromAxisAngle(surfaceNormal, headingAngle);
  
  // Combine: first align to surface, then rotate around normal to face forward
  const finalQuat = new THREE.Quaternion();
  finalQuat.multiplyQuaternions(headingQuat, surfaceQuat);
  antGroup.setRotationFromQuaternion(finalQuat);

  thorax.updateMatrixWorld(true);
  worldToThorax.copy(thorax.matrixWorld).invert();

  legs.forEach((leg, i) => {
    // Tripod phase
    const phase = ((t / period) + (tripodA.has(i) ? 0 : 0.5)) % 1;
    let inStance = (phase < 0.5);

    // Desired foot target on plane in world space
    // Base position: home in thorax space, then add walking offset along body +Z
    tmp.targetThorax.copy(home[i]);
    const stepOffset = (inStance ? -1 : 1) * (STEP_LENGTH * (inStance ? (phase/0.5) : ((phase-0.5)/0.5)) - STEP_LENGTH/2);
    tmp.targetThorax.z += stepOffset;

    // Transform to world
    tmp.targetWorld.copy(tmp.targetThorax).applyMatrix4(thorax.matrixWorld);

    // Project foot target onto sphere surface properly
    // Calculate the vector from sphere center to the target point
    const toTarget = new THREE.Vector3(
      tmp.targetWorld.x - SPHERE_CENTER.x,
      tmp.targetWorld.y - SPHERE_CENTER.y,
      tmp.targetWorld.z - SPHERE_CENTER.z
    );

    // Project this point onto the sphere surface
    const targetDist = toTarget.length();
    if (targetDist > 0.001) {
      // Normalize and scale to sphere radius to get surface point
      toTarget.normalize().multiplyScalar(SPHERE_RADIUS);
      tmp.targetWorld.x = SPHERE_CENTER.x + toTarget.x;
      tmp.targetWorld.y = SPHERE_CENTER.y + toTarget.y;
      tmp.targetWorld.z = SPHERE_CENTER.z + toTarget.z;
    }

    // Add swing height above surface
    if (!inStance) {
      const swingHeight = STEP_HEIGHT * Math.sin(Math.PI * ((phase - 0.5) / 0.5));
      const normal = getSurfaceNormal(tmp.targetWorld.x, tmp.targetWorld.z);
      tmp.targetWorld.x += normal.x * swingHeight;
      tmp.targetWorld.y += normal.y * swingHeight;
      tmp.targetWorld.z += normal.z * swingHeight;
    }

    const st = state[i];
    if (!st.initialized) {
      st.planted.copy(tmp.targetWorld);
      st.current.copy(tmp.targetWorld);
      st.initialized = true;
      st.inStancePrev = inStance;
    }

    if (inStance) {
      if (!st.inStancePrev) {
        // Just landed: fix planted position to the new point on the ground
        st.planted.copy(tmp.targetWorld);
      }
      // Hold planted position during stance (no slipping)
      st.current.copy(st.planted);
    } else {
      // Swing to next placement target with gentle interpolation
      st.current.lerp(tmp.targetWorld, 0.25);
    }
    st.inStancePrev = inStance;

    // Place debug marker (by default, show desired target; after IK we will update to actual tip)
    footMarkers[i].position.copy(st.current);

    // Solve yaw s.t. planted lies in coxa local XY plane (z≈0), then do IK in coxa local
    // First pass: compute coxa local point and yaw correction to zero z
    const computeWorldToCoxa = () => new THREE.Matrix4().copy(leg.coxaPivot.matrixWorld).invert();
    let worldToCoxa = computeWorldToCoxa();
    let pCoxa = st.current.clone().applyMatrix4(worldToCoxa); // in coxa local
    const dYaw = Math.atan2(pCoxa.z, pCoxa.x);
    leg.legRoot.rotation.y -= dYaw; // rotate so z→0
    leg.legRoot.updateMatrixWorld(true);
    // Recompute with corrected yaw
    worldToCoxa = computeWorldToCoxa();
    pCoxa = st.current.clone().applyMatrix4(worldToCoxa);
    // Planar IK in coxa local XY
    const xLeg = pCoxa.x - COXA_LENGTH;
    const yLeg = pCoxa.y;

    // If stance target is barely reachable, trigger swing early to avoid sliding
    if (inStance) {
      const L1 = FEMUR_LENGTH, L2 = TIBIA_LENGTH;
      const D = Math.hypot(xLeg, yLeg);
      const MAX_REACH = L1 + L2 - 1e-3;
      if (D > MAX_REACH * 0.985) {
        inStance = false; // switch to swing early
      }
    }

    if (inStance) {
      // Exact IK in stance so the tibia tip touches ground at st.current
      const res = solvePlanarIK(xLeg, yLeg);
      let femur = res.femur;
      let tibia = res.tibia;

      // Verify the IK solution actually reaches the target
      const reachX = FEMUR_LENGTH * Math.cos(femur) + TIBIA_LENGTH * Math.cos(femur + tibia);
      const reachY = FEMUR_LENGTH * Math.sin(femur) + TIBIA_LENGTH * Math.sin(femur + tibia);
      const error = Math.hypot(reachX - xLeg, reachY - yLeg);

      // If error is too large, adjust to get closer to surface
      if (error > 0.01) {
        // Try to extend leg more to reach surface
        const targetDist = Math.hypot(xLeg, yLeg);
        const maxReach = FEMUR_LENGTH + TIBIA_LENGTH - 0.001;
        if (targetDist < maxReach) {
          // Re-solve with adjusted target
          const scale = Math.min(1.0, maxReach / targetDist);
          const adjRes = solvePlanarIK(xLeg * scale, yLeg * scale);
          femur = adjRes.femur;
          tibia = adjRes.tibia;
        }
      }

      // Apply joint limits
      femur = THREE.MathUtils.clamp(femur, -1.6, 0.2);
      tibia = THREE.MathUtils.clamp(tibia, 0.0, 2.6);
      leg.femurPivot.rotation.z = femur;
      leg.tibiaPivot.rotation.z = tibia;
    } else {
      // During swing, keep tibia near neutral and use femur to lift/place for stability
      const TIBIA_NEUTRAL = 0.8;
      const L1 = FEMUR_LENGTH, L2 = TIBIA_LENGTH;
      const Dfixed = Math.sqrt(L1*L1 + L2*L2 + 2*L1*L2*Math.cos(TIBIA_NEUTRAL));
      const r = Math.hypot(xLeg, yLeg) || 1e-6;
      const scale = Dfixed / r;
      const xFixed = xLeg * scale;
      const yFixed = yLeg * scale;
      const phi = Math.atan2(yFixed, xFixed);
      const Aangle = Math.atan2(L2*Math.sin(TIBIA_NEUTRAL), L1 + L2*Math.cos(TIBIA_NEUTRAL));
      let femur = phi - Aangle;
      femur = THREE.MathUtils.clamp(femur, -1.6, 0.2);
      leg.femurPivot.rotation.z = femur;
      leg.tibiaPivot.rotation.z = TIBIA_NEUTRAL;
    }

    // Update marker to show actual foot tip (FK) to verify contact
    thorax.updateMatrixWorld(true);
    const tipLocal = new THREE.Vector3(TIBIA_LENGTH, 0, 0);
    const tipWorld = tipLocal.clone();
    legs[i].tibiaPivot.localToWorld(tipWorld);
    footMarkers[i].position.copy(tipWorld);

    // Optional stance logging (throttled)
    if (LOG_WALK && inStance && (FRAME_NO % LOG_EVERY === 0)) {
      // Compute coxa-local z for planted to verify in-plane
      const pC = st.current.clone().applyMatrix4(new THREE.Matrix4().copy(leg.coxaPivot.matrixWorld).invert());
      const axisZErr = pC.z; // ~0 if in plane
      const delta = tipWorld.clone().sub(st.current);
      const rn = rowName(leg.legRoot.position.z);
      console.log(JSON.stringify({
        frame: FRAME_NO,
        legIndex: i, side: leg.side, row: rn,
        planted: { x: +st.current.x.toFixed(4), y: +st.current.y.toFixed(4), z: +st.current.z.toFixed(4) },
        tipWorld: { x: +tipWorld.x.toFixed(4), y: +tipWorld.y.toFixed(4), z: +tipWorld.z.toFixed(4) },
        delta: { x: +delta.x.toFixed(4), y: +delta.y.toFixed(4), z: +delta.z.toFixed(4) },
        planeNormalDot: +axisZErr.toFixed(4),
      }));
    }
  });

  controls.update();
  renderer.render(scene, camera);
  
  // Debug leg positions on first frame only
  if (FRAME_NO === 1) {
    console.log('=== Leg positions at frame 1 ===');
    legs.forEach((leg, i) => {
      const tipLocal = new THREE.Vector3(TIBIA_LENGTH, 0, 0);
      const tipWorld = tipLocal.clone();
      leg.tibiaPivot.localToWorld(tipWorld);

      // Calculate distance from foot to sphere surface
      const footDistToCenter = tipWorld.distanceTo(SPHERE_CENTER);
      const footDistToSurface = footDistToCenter - SPHERE_RADIUS;

      console.log(`Leg ${i}: side=${leg.side}`);
      console.log(`  World pos:`, tipWorld);
      console.log(`  Distance to sphere center:`, footDistToCenter);
      console.log(`  Distance to sphere surface:`, footDistToSurface);
      console.log(`  Foot marker pos:`, footMarkers[i].position);
    });

    // Also log body distance on first frame
    const bodyPos = antGroup.position.clone();
    const bodyDistToCenter = bodyPos.distanceTo(SPHERE_CENTER);
    const bodyDistToSurface = bodyDistToCenter - SPHERE_RADIUS;
    console.log('=== Body Distance at frame 1 ===');
    console.log('Body position:', bodyPos);
    console.log('Distance to sphere center:', bodyDistToCenter);
    console.log('Distance to sphere surface:', bodyDistToSurface);
    console.log('Clearance value:', CLEARANCE);
  }
}

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Debug utilities: log feet and targets once when frozen
function fmt(v) { return `(${v.x.toFixed(3)}, ${v.y.toFixed(3)}, ${v.z.toFixed(3)})`; }
function rowName(z) { return z > 0.001 ? 'front' : (z < -0.001 ? 'rear' : 'middle'); }

function logFeet() {
  thorax.updateMatrixWorld(true);
  for (let i=0;i<legs.length;i++) {
    const leg = legs[i];
    // Desired target on curved surface at home pose
    const tThorax = home[i].clone();
    const tWorld = tThorax.applyMatrix4(thorax.matrixWorld);
    tWorld.y = getSurfacePoint(tWorld.x, tWorld.z); // should touch curved surface
    // Actual tibia tip
    const tipLocal = new THREE.Vector3(TIBIA_LENGTH, 0, 0);
    const tipWorld = tipLocal.clone();
    leg.tibiaPivot.localToWorld(tipWorld);
    // Also log the femur root and basis-projected target (for sanity)
    const femurRootWorld = new THREE.Vector3(COXA_LENGTH, 0, 0);
    leg.coxaPivot.localToWorld(femurRootWorld);
    const coxaQuatW = new THREE.Quaternion();
    leg.coxaPivot.getWorldQuaternion(coxaQuatW);
    const axisX = new THREE.Vector3(1,0,0).applyQuaternion(coxaQuatW).normalize();
    const axisY = new THREE.Vector3(0,1,0).applyQuaternion(coxaQuatW).normalize();
    const targetRelW = new THREE.Vector3().subVectors(tWorld, femurRootWorld);
    const xLeg = targetRelW.dot(axisX);
    const yLeg = targetRelW.dot(axisY);
    const delta = tipWorld.clone().sub(tWorld);
    const rn = rowName(leg.legRoot.position.z);
    console.log(JSON.stringify({
      legIndex: i, side: leg.side, row: rn,
      targetWorld: { x: +tWorld.x.toFixed(4), y: +tWorld.y.toFixed(4), z: +tWorld.z.toFixed(4) },
      tipWorld:    { x: +tipWorld.x.toFixed(4), y: +tipWorld.y.toFixed(4), z: +tipWorld.z.toFixed(4) },
      femurRoot:   { x: +femurRootWorld.x.toFixed(4), y: +femurRootWorld.y.toFixed(4), z: +femurRootWorld.z.toFixed(4) },
      legPlaneXY:  { x: +xLeg.toFixed(4), y: +yLeg.toFixed(4) },
      delta:       { x: +delta.x.toFixed(4), y: +delta.y.toFixed(4), z: +delta.z.toFixed(4) },
    }));
  }
}

animate();
</script>
</body>
</html>

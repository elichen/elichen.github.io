<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ant - Curved Surface IK</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { width: 100%; height: 100vh; display: block; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
<script>
// Ant walking with 2-bone IK on a curved surface

const COXA_LENGTH = 0.06;
const FEMUR_LENGTH = 0.12;
const TIBIA_LENGTH = 0.18;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0e13);
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(1.2, 0.6, 1.2);
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('c'), antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

scene.add(new THREE.AmbientLight(0x4a4a4a));
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(2,3,2);
dir.castShadow = true;
scene.add(dir);

// Define randomly oriented curved surface parameters
// Random angles for base plane orientation (limited to avoid extreme tilts)
const MAX_TILT = Math.PI / 6; // 30 degrees max tilt
const TILT_X = (Math.random() - 0.5) * 2 * MAX_TILT;
const TILT_Z = (Math.random() - 0.5) * 2 * MAX_TILT;

// Create base plane normal from tilts
const BASE_PLANE_NORMAL = new THREE.Vector3(
  Math.sin(TILT_X),
  Math.cos(TILT_X) * Math.cos(TILT_Z),
  Math.sin(TILT_Z)
).normalize();

// Random curvature parameters
const CURVE_RADIUS = 2.0 + Math.random() * 2.0; // Radius between 2 and 4
const CURVE_AXIS_ANGLE = Math.random() * Math.PI * 2; // Random angle for curve axis on plane

// Create local coordinate system for the plane
const planeY = BASE_PLANE_NORMAL;
const planeX = new THREE.Vector3(1, 0, 0);
if (Math.abs(planeY.x) > 0.9) {
  planeX.set(0, 1, 0);
}
planeX.sub(planeY.clone().multiplyScalar(planeX.dot(planeY))).normalize();
const planeZ = new THREE.Vector3().crossVectors(planeX, planeY);

// Curve axis in plane coordinates (direction along which surface curves)
const curveAxisLocal = new THREE.Vector3(
  Math.cos(CURVE_AXIS_ANGLE),
  0,
  Math.sin(CURVE_AXIS_ANGLE)
);

// Transform curve axis to world coordinates
const curveAxis = new THREE.Vector3()
  .addScaledVector(planeX, curveAxisLocal.x)
  .addScaledVector(planeZ, curveAxisLocal.z)
  .normalize();

const PLANE_POINT = new THREE.Vector3(0, 0, 0); // center point

// Log the surface parameters
console.log('Base plane normal:', BASE_PLANE_NORMAL);
console.log('Curve radius:', CURVE_RADIUS);
console.log('Curve axis:', curveAxis);
console.log('Tilt angles (degrees):', { x: TILT_X * 180/Math.PI, z: TILT_Z * 180/Math.PI });

// Helper function to get point on curved surface
function getSurfacePoint(x, z) {
  const p = new THREE.Vector3(x, 0, z);
  
  // Project point onto curve axis to find distance along curve
  const alongAxis = p.dot(curveAxis);
  
  // Calculate height based on cylindrical curve
  const curveHeight = CURVE_RADIUS * (1 - Math.cos(alongAxis / CURVE_RADIUS));
  
  // Get base plane height
  const basePlaneY = PLANE_POINT.y - (BASE_PLANE_NORMAL.x * (x - PLANE_POINT.x) + BASE_PLANE_NORMAL.z * (z - PLANE_POINT.z)) / BASE_PLANE_NORMAL.y;
  
  // Combine base plane with curvature
  return basePlaneY + curveHeight;
}

// Helper to get surface normal at a point
function getSurfaceNormal(x, z) {
  const eps = 0.01;
  const y = getSurfacePoint(x, z);
  const dx = getSurfacePoint(x + eps, z) - getSurfacePoint(x - eps, z);
  const dz = getSurfacePoint(x, z + eps) - getSurfacePoint(x, z - eps);
  
  // Normal is perpendicular to tangent vectors
  const normal = new THREE.Vector3(-dx/(2*eps), 1, -dz/(2*eps)).normalize();
  return normal;
}

// Create rotation quaternion to align Y-up to average surface normal
const planeQuat = new THREE.Quaternion();
const up = new THREE.Vector3(0, 1, 0);
const avgNormal = getSurfaceNormal(0, 0);
planeQuat.setFromUnitVectors(up, avgNormal);

const groundY = 0; // reference height

// Create curved surface mesh
const groundMat = new THREE.MeshStandardMaterial({ 
  color: 0x404040, 
  roughness: 0.8, 
  metalness: 0.1,
  side: THREE.DoubleSide 
});

// Generate curved surface geometry
const surfaceGeometry = new THREE.BufferGeometry();
const gridSize = 12;
const gridDivisions = 60;
const vertices = [];
const normals = [];
const indices = [];

// Generate vertices and normals
for (let i = 0; i <= gridDivisions; i++) {
  for (let j = 0; j <= gridDivisions; j++) {
    const x = (i / gridDivisions - 0.5) * gridSize;
    const z = (j / gridDivisions - 0.5) * gridSize;
    const y = getSurfacePoint(x, z);
    vertices.push(x, y, z);
    
    const normal = getSurfaceNormal(x, z);
    normals.push(normal.x, normal.y, normal.z);
  }
}

// Generate indices for triangles
for (let i = 0; i < gridDivisions; i++) {
  for (let j = 0; j < gridDivisions; j++) {
    const a = i * (gridDivisions + 1) + j;
    const b = a + 1;
    const c = (i + 1) * (gridDivisions + 1) + j;
    const d = c + 1;
    
    indices.push(a, b, c);
    indices.push(b, d, c);
  }
}

surfaceGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
surfaceGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
surfaceGeometry.setIndex(indices);

const ground = new THREE.Mesh(surfaceGeometry, groundMat);
ground.receiveShadow = true;
scene.add(ground);

// Add wireframe overlay for better visualization
const wireframeMat = new THREE.MeshBasicMaterial({ 
  color: 0x334455, 
  wireframe: true,
  transparent: true,
  opacity: 0.3
});
const wireframe = new THREE.Mesh(surfaceGeometry, wireframeMat);
scene.add(wireframe);

const axes = new THREE.AxesHelper(0.3);
scene.add(axes);

function createAnt() {
  const antGroup = new THREE.Group();
  const bodyMat = new THREE.MeshPhongMaterial({ color: 0x7A4426, shininess: 40 });
  const legMat = new THREE.MeshPhongMaterial({ color: 0x5C3317, shininess: 20 });

  // Body
  const thorax = new THREE.Mesh(new THREE.SphereGeometry(0.08, 20, 16), bodyMat);
  thorax.scale.set(1, 0.8, 1.2);
  thorax.castShadow = true;
  antGroup.add(thorax);

  const abdomen = new THREE.Mesh(new THREE.SphereGeometry(0.1, 20, 16), bodyMat);
  abdomen.scale.set(1, 0.8, 1.4);
  abdomen.position.set(0, 0, -0.2);
  abdomen.castShadow = true;
  antGroup.add(abdomen);

  const head = new THREE.Mesh(new THREE.SphereGeometry(0.06, 16, 12), bodyMat);
  head.position.set(0, 0, 0.15);
  head.castShadow = true;
  antGroup.add(head);

  // Antennae (base pivot so attachment stays correct)
  const antennaLength = 0.15;
  const antennaGeom = new THREE.CylinderGeometry(0.002, 0.005, antennaLength, 8);
  const antennaMat = new THREE.MeshPhongMaterial({ color: 0x5C3317 });
  for (let i=0;i<2;i++) {
    const side = i===0 ? -1 : 1; // -1 = left, +1 = right
    const root = new THREE.Group();
    root.position.set(side*0.03, 0.02, 0.055);
    root.rotation.x = Math.PI/3;        // tilt forward (+Z)
    root.rotation.z = -side*Math.PI/6;  // splay outward
    head.add(root);

    const ant = new THREE.Mesh(antennaGeom, antennaMat);
    ant.castShadow = true;
    ant.position.y = antennaLength/2;   // extend from base
    root.add(ant);
  }

  // Leg rig (consistent axes):
  // - legRoot: yaw around Y
  // - coxaPivot: fixed outward splay around Y
  // - femurPivot: rotate around Z in XY plane
  // - tibiaPivot: rotate around Z in XY plane
  const legs = [];
  const legPositions = [
    [ 0.06, 0.00,  0.05,  1],
    [ 0.06, 0.00,  0.00,  1],
    [ 0.06, 0.00, -0.05,  1],
    [-0.06, 0.00,  0.05, -1],
    [-0.06, 0.00,  0.00, -1],
    [-0.06, 0.00, -0.05, -1],
  ];

  legPositions.forEach((p, index) => {
    const [px, py, pz, side] = p;

    const legRoot = new THREE.Group();
    legRoot.position.set(px, py, pz);
    thorax.add(legRoot);

    const coxaPivot = new THREE.Group();
    // Orient by row: front forward, middle sideways, rear backward with slight outward splay
    const splayMag = Math.PI/8;
    const isFront = pz > 0.001;
    const isBack  = pz < -0.001;
    let baseYaw;
    if (isFront) {
      baseYaw = -Math.PI/2 + side * splayMag; // face +Z
    } else if (isBack) {
      baseYaw =  Math.PI/2 - side * splayMag; // face -Z
    } else {
      baseYaw = side > 0 ? 0 : Math.PI;       // sideways outward
    }
    coxaPivot.rotation.y = baseYaw;
    legRoot.add(coxaPivot);

    const coxa = new THREE.Mesh(new THREE.CylinderGeometry(0.012, 0.010, COXA_LENGTH, 8), legMat);
    coxa.rotation.z = -Math.PI/2; // along +X
    coxa.position.x = COXA_LENGTH/2;
    coxa.castShadow = true;
    coxaPivot.add(coxa);

    const femurPivot = new THREE.Group();
    femurPivot.position.x = COXA_LENGTH;
    coxaPivot.add(femurPivot);

    const femur = new THREE.Mesh(new THREE.CylinderGeometry(0.009, 0.007, FEMUR_LENGTH, 8), legMat);
    femur.rotation.z = -Math.PI/2; // along +X
    femur.position.x = FEMUR_LENGTH/2;
    femur.castShadow = true;
    femurPivot.add(femur);

    const tibiaPivot = new THREE.Group();
    tibiaPivot.position.x = FEMUR_LENGTH;
    femurPivot.add(tibiaPivot);

    const tibia = new THREE.Mesh(new THREE.CylinderGeometry(0.007, 0.004, TIBIA_LENGTH, 8), legMat);
    tibia.rotation.z = -Math.PI/2; // along +X
    tibia.position.x = TIBIA_LENGTH/2;
    tibia.castShadow = true;
    tibiaPivot.add(tibia);

    // Neutral, comfortable pose to match static model
    femurPivot.rotation.z = -0.9;
    tibiaPivot.rotation.z = 0.8;

    legs.push({ index, side, legRoot, coxaPivot, femurPivot, tibiaPivot });
  });

  return { antGroup, thorax, legs };
}

const { antGroup, thorax, legs } = createAnt();
scene.add(antGroup);

// Body placement calibrated to neutral pose: foot tips touch the ground
const FEMUR_NEUTRAL = -0.9;
const TIBIA_NEUTRAL = 0.8;
const CLEARANCE = -(FEMUR_LENGTH*Math.sin(FEMUR_NEUTRAL) + TIBIA_LENGTH*Math.sin(FEMUR_NEUTRAL + TIBIA_NEUTRAL));

// Orient ant body to match curved surface normal at starting position
const initialZ = 0;
const initialX = 0;
const surfaceY = getSurfacePoint(initialX, initialZ);
const surfaceNormal = getSurfaceNormal(initialX, initialZ);

// Project clearance along surface normal
const clearanceVec = new THREE.Vector3().copy(surfaceNormal).multiplyScalar(CLEARANCE);
antGroup.position.set(
  initialX + clearanceVec.x, 
  surfaceY + clearanceVec.y, 
  initialZ + clearanceVec.z
);

// Align ant to surface normal
const surfaceQuat = new THREE.Quaternion();
surfaceQuat.setFromUnitVectors(up, surfaceNormal);
antGroup.setRotationFromQuaternion(surfaceQuat);

// Tripod gait
const tripodA = new Set([0,2,4]);
const period = 2.4; // seconds for full cycle

// Home offsets in thorax space for foot targets computed from the neutral FK
const home = (() => {
  thorax.updateMatrixWorld(true);
  const worldToThoraxMat = new THREE.Matrix4().copy(thorax.matrixWorld).invert();
  return legs.map((leg) => {
    // get tibia tip in world at current neutral rotations
    const tipLocal = new THREE.Vector3(TIBIA_LENGTH, 0, 0);
    const tipWorld = tipLocal.clone();
    leg.tibiaPivot.localToWorld(tipWorld);
    // convert to thorax local
    return tipWorld.applyMatrix4(worldToThoraxMat);
  });
})();

// Helpers
const worldToThorax = new THREE.Matrix4();
const Y = new THREE.Vector3(0,1,0);
const tmp = {
  targetWorld: new THREE.Vector3(),
  targetThorax: new THREE.Vector3(),
  relFromRoot: new THREE.Vector3(),
  yawQuat: new THREE.Quaternion(),
  tempQuat: new THREE.Quaternion(),
  pA: new THREE.Vector3(), pB: new THREE.Vector3(),
};

// Debug markers
const footMarkers = [];
for (let i=0;i<legs.length;i++) {
  const s = new THREE.Mesh(new THREE.SphereGeometry(0.01, 10, 8), new THREE.MeshBasicMaterial({ color: tripodA.has(i)?0x33ffaa:0xffaa33 }));
  scene.add(s);
  footMarkers.push(s);
}

// IK solver in XY plane (after yaw unrotation and coxa splay removal)
function solvePlanarIK(x, y) {
  const L1 = FEMUR_LENGTH, L2 = TIBIA_LENGTH;
  const D = Math.max(1e-6, Math.min(L1 + L2 - 1e-4, Math.hypot(x, y)));
  const cosKnee = THREE.MathUtils.clamp((L1*L1 + L2*L2 - D*D) / (2*L1*L2), -1, 1);
  // Mechanical knee rotation (0 straight → pi folded); matches our rig's tibiaPivot rotation
  const knee = Math.PI - Math.acos(cosKnee);
  const femur = Math.atan2(y, x) - Math.atan2(L2 * Math.sin(knee), L1 + L2 * Math.cos(knee));
  return { femur, tibia: knee };
}

// State per leg
const state = legs.map((leg, i) => ({
  planted: new THREE.Vector3(),
  current: new THREE.Vector3(),
  initialized: false,
  inStancePrev: false,
}));

const STEP_HEIGHT = 0.04;
const STEP_LENGTH = 0.08;
const FOOT_OFFSET = 0.0; // exact ground contact in stance
const bodySpeed = 0.04; // slower forward for inspection

const LOG_WALK = true;
const LOG_EVERY = 20;
let FRAME_NO = 0;

let t0 = performance.now() / 1000;

function animate() {
  requestAnimationFrame(animate);
  FRAME_NO++;
  const t = performance.now()/1000 - t0; // Enable animation

  // Move body forward along the curved surface
  const bodyZ = t * bodySpeed;
  const bodyX = 0; // Keep X=0 for simplicity
  const surfaceY = getSurfacePoint(bodyX, bodyZ);
  const surfaceNormal = getSurfaceNormal(bodyX, bodyZ);
  
  // Project clearance along surface normal
  const clearanceVec = new THREE.Vector3().copy(surfaceNormal).multiplyScalar(CLEARANCE);
  antGroup.position.set(
    bodyX + clearanceVec.x, 
    surfaceY + clearanceVec.y, 
    bodyZ + clearanceVec.z
  );
  
  // Maintain orientation: aligned to surface normal, facing +Z
  const surfaceQuat = new THREE.Quaternion();
  surfaceQuat.setFromUnitVectors(up, surfaceNormal);
  antGroup.setRotationFromQuaternion(surfaceQuat);

  thorax.updateMatrixWorld(true);
  worldToThorax.copy(thorax.matrixWorld).invert();

  legs.forEach((leg, i) => {
    // Tripod phase
    const phase = ((t / period) + (tripodA.has(i) ? 0 : 0.5)) % 1;
    let inStance = (phase < 0.5);

    // Desired foot target on plane in world space
    // Base position: home in thorax space, then add walking offset along body +Z
    tmp.targetThorax.copy(home[i]);
    const stepOffset = (inStance ? -1 : 1) * (STEP_LENGTH * (inStance ? (phase/0.5) : ((phase-0.5)/0.5)) - STEP_LENGTH/2);
    tmp.targetThorax.z += stepOffset;

    // Transform to world
    tmp.targetWorld.copy(tmp.targetThorax).applyMatrix4(thorax.matrixWorld);
    // Constrain to curved surface, with optional swing lift
    const surfaceY = getSurfacePoint(tmp.targetWorld.x, tmp.targetWorld.z);
    tmp.targetWorld.y = surfaceY + (inStance ? 0 : STEP_HEIGHT*Math.sin(Math.PI*((phase-0.5)/0.5)));

    const st = state[i];
    if (!st.initialized) {
      st.planted.copy(tmp.targetWorld);
      st.current.copy(tmp.targetWorld);
      st.initialized = true;
      st.inStancePrev = inStance;
    }

    if (inStance) {
      if (!st.inStancePrev) {
        // Just landed: fix planted position to the new point on the ground
        st.planted.copy(tmp.targetWorld);
      }
      // Hold planted position during stance (no slipping)
      st.current.copy(st.planted);
    } else {
      // Swing to next placement target with gentle interpolation
      st.current.lerp(tmp.targetWorld, 0.25);
    }
    st.inStancePrev = inStance;

    // Place debug marker (by default, show desired target; after IK we will update to actual tip)
    footMarkers[i].position.copy(st.current);

    // Solve yaw s.t. planted lies in coxa local XY plane (z≈0), then do IK in coxa local
    // First pass: compute coxa local point and yaw correction to zero z
    const computeWorldToCoxa = () => new THREE.Matrix4().copy(leg.coxaPivot.matrixWorld).invert();
    let worldToCoxa = computeWorldToCoxa();
    let pCoxa = st.current.clone().applyMatrix4(worldToCoxa); // in coxa local
    const dYaw = Math.atan2(pCoxa.z, pCoxa.x);
    leg.legRoot.rotation.y -= dYaw; // rotate so z→0
    leg.legRoot.updateMatrixWorld(true);
    // Recompute with corrected yaw
    worldToCoxa = computeWorldToCoxa();
    pCoxa = st.current.clone().applyMatrix4(worldToCoxa);
    // Planar IK in coxa local XY
    const xLeg = pCoxa.x - COXA_LENGTH;
    const yLeg = pCoxa.y;

    // If stance target is barely reachable, trigger swing early to avoid sliding
    if (inStance) {
      const L1 = FEMUR_LENGTH, L2 = TIBIA_LENGTH;
      const D = Math.hypot(xLeg, yLeg);
      const MAX_REACH = L1 + L2 - 1e-3;
      if (D > MAX_REACH * 0.985) {
        inStance = false; // switch to swing early
      }
    }

    if (inStance) {
      // Exact IK in stance so the tibia tip touches ground at st.current
      const res = solvePlanarIK(xLeg, yLeg);
      const femur = THREE.MathUtils.clamp(res.femur, -1.6, 0.2);
      const tibia = THREE.MathUtils.clamp(res.tibia, 0.0, 2.6); // full IK in stance to ensure contact
      leg.femurPivot.rotation.z = femur;
      leg.tibiaPivot.rotation.z = tibia;
    } else {
      // During swing, keep tibia near neutral and use femur to lift/place for stability
      const TIBIA_NEUTRAL = 0.8;
      const L1 = FEMUR_LENGTH, L2 = TIBIA_LENGTH;
      const Dfixed = Math.sqrt(L1*L1 + L2*L2 + 2*L1*L2*Math.cos(TIBIA_NEUTRAL));
      const r = Math.hypot(xLeg, yLeg) || 1e-6;
      const scale = Dfixed / r;
      const xFixed = xLeg * scale;
      const yFixed = yLeg * scale;
      const phi = Math.atan2(yFixed, xFixed);
      const Aangle = Math.atan2(L2*Math.sin(TIBIA_NEUTRAL), L1 + L2*Math.cos(TIBIA_NEUTRAL));
      let femur = phi - Aangle;
      femur = THREE.MathUtils.clamp(femur, -1.6, 0.2);
      leg.femurPivot.rotation.z = femur;
      leg.tibiaPivot.rotation.z = TIBIA_NEUTRAL;
    }

    // Update marker to show actual foot tip (FK) to verify contact
    thorax.updateMatrixWorld(true);
    const tipLocal = new THREE.Vector3(TIBIA_LENGTH, 0, 0);
    const tipWorld = tipLocal.clone();
    legs[i].tibiaPivot.localToWorld(tipWorld);
    footMarkers[i].position.copy(tipWorld);

    // Optional stance logging (throttled)
    if (LOG_WALK && inStance && (FRAME_NO % LOG_EVERY === 0)) {
      // Compute coxa-local z for planted to verify in-plane
      const pC = st.current.clone().applyMatrix4(new THREE.Matrix4().copy(leg.coxaPivot.matrixWorld).invert());
      const axisZErr = pC.z; // ~0 if in plane
      const delta = tipWorld.clone().sub(st.current);
      const rn = rowName(leg.legRoot.position.z);
      console.log(JSON.stringify({
        frame: FRAME_NO,
        legIndex: i, side: leg.side, row: rn,
        planted: { x: +st.current.x.toFixed(4), y: +st.current.y.toFixed(4), z: +st.current.z.toFixed(4) },
        tipWorld: { x: +tipWorld.x.toFixed(4), y: +tipWorld.y.toFixed(4), z: +tipWorld.z.toFixed(4) },
        delta: { x: +delta.x.toFixed(4), y: +delta.y.toFixed(4), z: +delta.z.toFixed(4) },
        planeNormalDot: +axisZErr.toFixed(4),
      }));
    }
  });

  controls.update();
  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Debug utilities: log feet and targets once when frozen
function fmt(v) { return `(${v.x.toFixed(3)}, ${v.y.toFixed(3)}, ${v.z.toFixed(3)})`; }
function rowName(z) { return z > 0.001 ? 'front' : (z < -0.001 ? 'rear' : 'middle'); }

function logFeet() {
  thorax.updateMatrixWorld(true);
  for (let i=0;i<legs.length;i++) {
    const leg = legs[i];
    // Desired target on curved surface at home pose
    const tThorax = home[i].clone();
    const tWorld = tThorax.applyMatrix4(thorax.matrixWorld);
    tWorld.y = getSurfacePoint(tWorld.x, tWorld.z); // should touch curved surface
    // Actual tibia tip
    const tipLocal = new THREE.Vector3(TIBIA_LENGTH, 0, 0);
    const tipWorld = tipLocal.clone();
    leg.tibiaPivot.localToWorld(tipWorld);
    // Also log the femur root and basis-projected target (for sanity)
    const femurRootWorld = new THREE.Vector3(COXA_LENGTH, 0, 0);
    leg.coxaPivot.localToWorld(femurRootWorld);
    const coxaQuatW = new THREE.Quaternion();
    leg.coxaPivot.getWorldQuaternion(coxaQuatW);
    const axisX = new THREE.Vector3(1,0,0).applyQuaternion(coxaQuatW).normalize();
    const axisY = new THREE.Vector3(0,1,0).applyQuaternion(coxaQuatW).normalize();
    const targetRelW = new THREE.Vector3().subVectors(tWorld, femurRootWorld);
    const xLeg = targetRelW.dot(axisX);
    const yLeg = targetRelW.dot(axisY);
    const delta = tipWorld.clone().sub(tWorld);
    const rn = rowName(leg.legRoot.position.z);
    console.log(JSON.stringify({
      legIndex: i, side: leg.side, row: rn,
      targetWorld: { x: +tWorld.x.toFixed(4), y: +tWorld.y.toFixed(4), z: +tWorld.z.toFixed(4) },
      tipWorld:    { x: +tipWorld.x.toFixed(4), y: +tipWorld.y.toFixed(4), z: +tipWorld.z.toFixed(4) },
      femurRoot:   { x: +femurRootWorld.x.toFixed(4), y: +femurRootWorld.y.toFixed(4), z: +femurRootWorld.z.toFixed(4) },
      legPlaneXY:  { x: +xLeg.toFixed(4), y: +yLeg.toFixed(4) },
      delta:       { x: +delta.x.toFixed(4), y: +delta.y.toFixed(4), z: +delta.z.toFixed(4) },
    }));
  }
}

animate();
</script>
</body>
</html>

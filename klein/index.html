<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ant on Klein Bottle - Improved Leg Implementation v2</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100vh; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/geometries/ParametricGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // --- Constants ---
        // Scale down by half for better proportions on Klein bottle
        const COXA_LENGTH = 0.03;
        const FEMUR_LENGTH = 0.06;
        const TIBIA_LENGTH = 0.09;

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05;
        
        const kleinBottleParametric = (u_param, v_param, target) => {
            const u = u_param * Math.PI * 2; const v = v_param * Math.PI * 2;
            let x, y, z;
            if (u < Math.PI) {
                x = 3*Math.cos(u)*(1+Math.sin(u))+(2*(1-Math.cos(u)/2))*Math.cos(u)*Math.cos(v);
                y = 8*Math.sin(u)+(2*(1-Math.cos(u)/2))*Math.sin(u)*Math.cos(v);
                z = (2*(1-Math.cos(u)/2))*Math.sin(v);
            } else {
                x = 3*Math.cos(u)*(1+Math.sin(u))+(2*(1-Math.cos(u)/2))*Math.cos(v+Math.PI);
                y = 8*Math.sin(u);
                z = (2*(1-Math.cos(u)/2))*Math.sin(v);
            }
            target.set(x*0.25, y*0.25, z*0.25);
        };

        const geometry = new THREE.ParametricGeometry(kleinBottleParametric, 120, 120);
        const material = new THREE.MeshPhongMaterial({ 
            color: 0x77bbff, side: THREE.DoubleSide, transparent: true, opacity: 0.8,
            shininess: 90, specular: 0x333333,
        });
        const kleinMesh = new THREE.Mesh(geometry, material);
        kleinMesh.receiveShadow = true;
        scene.add(kleinMesh);

        // Raycaster for finding surface points
        const raycaster = new THREE.Raycaster();

        scene.add(new THREE.AmbientLight(0x707070));
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(8, 12, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        camera.position.set(0, 3, 10); camera.lookAt(0, 0, 0);

        // Tripod gait groups (needed before createAnt)
        const tripodA = new Set([0, 2, 4]); // Right front, right back, left middle

        const createAnt = () => {
            const antGroup = new THREE.Group();
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0x7A4426, shininess: 40 });
            const legMat = new THREE.MeshPhongMaterial({ color: 0x5C3317, shininess: 20 });
            
            // Body - scaled down by half from sphere
            const thorax = new THREE.Mesh(new THREE.SphereGeometry(0.04, 20, 16), bodyMat);
            thorax.scale.set(1, 0.8, 1.2);
            thorax.castShadow = true;
            antGroup.add(thorax);

            const abdomen = new THREE.Mesh(new THREE.SphereGeometry(0.05, 20, 16), bodyMat);
            abdomen.scale.set(1, 0.8, 1.4);
            abdomen.position.set(0, 0, -0.1);
            abdomen.castShadow = true;
            antGroup.add(abdomen);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.03, 16, 12), bodyMat);
            head.position.set(0, 0, 0.075);
            head.castShadow = true;
            antGroup.add(head);
            
            // Antennae (base pivot so attachment stays correct) - scaled down by half
            const antennaLength = 0.075;
            const antennaGeom = new THREE.CylinderGeometry(0.001, 0.0025, antennaLength, 8);
            const antennaMat = new THREE.MeshPhongMaterial({ color: 0x5C3317 });
            for (let i=0; i<2; i++) {
                const side = i===0 ? -1 : 1; // -1 = left, +1 = right
                const root = new THREE.Group();
                root.position.set(side*0.015, 0.01, 0.0275);
                root.rotation.x = Math.PI/3;        // tilt forward (+Z)
                root.rotation.z = -side*Math.PI/6;  // splay outward
                head.add(root);

                const ant = new THREE.Mesh(antennaGeom, antennaMat);
                ant.castShadow = true;
                ant.position.y = antennaLength/2;   // extend from base
                root.add(ant);
            }
            
            // Leg rig (consistent axes):
            // - legRoot: yaw around Y
            // - coxaPivot: fixed outward splay around Y
            // - femurPivot: rotate around Z in XY plane
            // - tibiaPivot: rotate around Z in XY plane
            const legs = [];
            const legPositions = [
                [ 0.03, 0.00,  0.025,  1],
                [ 0.03, 0.00,  0.00,   1],
                [ 0.03, 0.00, -0.025,  1],
                [-0.03, 0.00,  0.025, -1],
                [-0.03, 0.00,  0.00,  -1],
                [-0.03, 0.00, -0.025, -1],
            ];

            legPositions.forEach((p, index) => {
                const [px, py, pz, side] = p;

                const legRoot = new THREE.Group();
                legRoot.position.set(px, py, pz);
                thorax.add(legRoot);

                const coxaPivot = new THREE.Group();
                // Orient by row: front forward, middle sideways, rear backward with slight outward splay
                const splayMag = Math.PI/8;
                const isFront = pz > 0.001;
                const isBack  = pz < -0.001;
                let baseYaw;
                if (isFront) {
                    baseYaw = -Math.PI/2 + side * splayMag; // face +Z
                } else if (isBack) {
                    baseYaw =  Math.PI/2 - side * splayMag; // face -Z
                } else {
                    baseYaw = side > 0 ? 0 : Math.PI;       // sideways outward
                }
                coxaPivot.rotation.y = baseYaw;
                legRoot.add(coxaPivot);

                const coxa = new THREE.Mesh(new THREE.CylinderGeometry(0.006, 0.005, COXA_LENGTH, 8), legMat);
                coxa.rotation.z = -Math.PI/2; // along +X
                coxa.position.x = COXA_LENGTH/2;
                coxa.castShadow = true;
                coxaPivot.add(coxa);

                const femurPivot = new THREE.Group();
                femurPivot.position.x = COXA_LENGTH;
                coxaPivot.add(femurPivot);

                const femur = new THREE.Mesh(new THREE.CylinderGeometry(0.0045, 0.0035, FEMUR_LENGTH, 8), legMat);
                femur.rotation.z = -Math.PI/2; // along +X
                femur.position.x = FEMUR_LENGTH/2;
                femur.castShadow = true;
                femurPivot.add(femur);

                const tibiaPivot = new THREE.Group();
                tibiaPivot.position.x = FEMUR_LENGTH;
                femurPivot.add(tibiaPivot);

                const tibia = new THREE.Mesh(new THREE.CylinderGeometry(0.0035, 0.002, TIBIA_LENGTH, 8), legMat);
                tibia.rotation.z = -Math.PI/2; // along +X
                tibia.position.x = TIBIA_LENGTH/2;
                tibia.castShadow = true;
                tibiaPivot.add(tibia);

                // Neutral, comfortable pose to match static model
                femurPivot.rotation.z = -0.9;
                tibiaPivot.rotation.z = 0.8;
                // Get tripod phase offset
                const phaseOffset = tripodA.has(index) ? 0 : 0.5;

                // Refined deltaU multipliers
                let du_multiplier = 1.0; // Default for middle
                if (pz > 0) du_multiplier = 0.8; // Front legs less splayed
                else if (pz < 0) du_multiplier = 0.9; // Rear legs

                legs.push({
                    index, side, legRoot, coxaPivot, femurPivot, tibiaPivot,
                    plantedT: new THREE.Vector3(),
                    phaseOffset: phaseOffset,
                    isRear: pz < -0.001,
                    // Foot placement offsets relative to body
                    deltaU: 0.035 * side * du_multiplier,
                    deltaV: 0.03 * (pz > 0 ? 1.0 : pz < 0 ? -1.0 : (index % 2 === 0 ? 0.25 : -0.25)),
                    lastPhase: 0,
                    currentTarget: new THREE.Vector3(),
                    swingStartPos: new THREE.Vector3(),
                    initialized: false,
                });
            });
            return { antGroup, thorax, abdomen, head, legs };
        };
        
        const { antGroup, thorax, abdomen, head, legs } = createAnt();
        scene.add(antGroup);

        // Debug markers (scaled down by half from sphere's 0.01)
        const footMarkers = [];
        for (let i=0; i<legs.length; i++) {
            const s = new THREE.Mesh(
                new THREE.SphereGeometry(0.005, 10, 8),
                new THREE.MeshBasicMaterial({ color: tripodA.has(i) ? 0x33ffaa : 0xffaa33 })
            );
            scene.add(s);
            footMarkers.push(s);
        }

        // State per leg (from sphere)
        const state = legs.map((leg, i) => ({
            planted: new THREE.Vector3(),
            current: new THREE.Vector3(),
            initialized: false,
            inStancePrev: false,
        }));

        // Match sphere implementation timing
        const bodySpeed = 0.04; // Same as sphere
        const period = 2400; // Same as sphere (2.4 seconds)
        const STEP_HEIGHT = 0.02; // Scaled down by half from sphere's 0.04
        const STEP_LENGTH = 0.04; // Scaled down by half from sphere's 0.08
        const epsilon = 0.0001;
        // Calculate proper body clearance based on leg dimensions
        // For the scaled-down ant, we need much less clearance
        const FEMUR_ANGLE_NEUTRAL = -0.9; // Downward angle
        const TIBIA_ANGLE_NEUTRAL = 0.8;  // Knee bend
        // Calculate vertical reach when legs are in neutral position
        // This is the Y-distance from thorax origin to foot tips in neutral pose
        const VERTICAL_REACH = FEMUR_LENGTH * Math.sin(FEMUR_ANGLE_NEUTRAL) +
                              TIBIA_LENGTH * Math.sin(FEMUR_ANGLE_NEUTRAL + TIBIA_ANGLE_NEUTRAL);
        const CLEARANCE_FROM_LEGS = Math.abs(VERTICAL_REACH);
        // Body should be positioned so legs can comfortably reach the surface
        // Reduce from full clearance so legs are more extended (more realistic)
        const BODY_OFFSET = CLEARANCE_FROM_LEGS * 0.75; // 75% clearance for natural stance
        const FOOT_SURFACE_OFFSET = 0.0; // Start with feet exactly on surface

        // Debug: Log scaled dimensions
        console.log('Scaled ant dimensions:');
        console.log('  COXA_LENGTH:', COXA_LENGTH);
        console.log('  FEMUR_LENGTH:', FEMUR_LENGTH);
        console.log('  TIBIA_LENGTH:', TIBIA_LENGTH);
        console.log('  Total reach:', COXA_LENGTH + FEMUR_LENGTH + TIBIA_LENGTH);
        console.log('  Calculated BODY_OFFSET:', BODY_OFFSET);
        const PHASE_BLEND_DURATION = 0.1;

        const _vec = {
            p: new THREE.Vector3(), p_du: new THREE.Vector3(), p_dv: new THREE.Vector3(),
            du: new THREE.Vector3(), dv: new THREE.Vector3(), N: new THREE.Vector3(), F: new THREE.Vector3(),
            antOffsetPos: new THREE.Vector3(), lookAtTarget: new THREE.Vector3(),
            footTargetSurface: new THREE.Vector3(), normalAtFootTarget: new THREE.Vector3(),
            correctedFootNormal: new THREE.Vector3(),
            swingStartWorld: new THREE.Vector3(),
            swingLerpBase: new THREE.Vector3(),
            finalFootTargetWorld: new THREE.Vector3(),
            targetInThorax: new THREE.Vector3(), targetRelToLegRoot: new THREE.Vector3(),
            targetInYawedLegRoot: new THREE.Vector3(),
            targetWorld: new THREE.Vector3(), // Added for world space foot targeting
            Y_AXIS: new THREE.Vector3(0,1,0), Z_AXIS: new THREE.Vector3(0,0,1),
            tempQuat: new THREE.Quaternion(),
            temp1: new THREE.Vector3(), temp2: new THREE.Vector3()
        };

        // Variables for logging
        let FRAME_NO = 0;
        const LOG_WALK = true;
        const LOG_EVERY = 20; // Same as sphere
        let t0 = performance.now() / 1000; // Track actual time like sphere
        const tempMatrix = new THREE.Matrix4(); 
        const worldToLocalMatrix = new THREE.Matrix4();
        
        const computeKleinBottlePoint = (u,v,target) => { 
            kleinBottleParametric(u/(2*Math.PI),v/(2*Math.PI),target); 
            return target; 
        };
        
        const computeSurfaceNormal = (u,v,target) => {
            const un=u/(2*Math.PI), vn=v/(2*Math.PI), epsNorm=0.00001;
            computeKleinBottlePoint(u,v,_vec.p);
            computeKleinBottlePoint(u+epsNorm*(2*Math.PI),v,_vec.p_du);
            computeKleinBottlePoint(u,v+epsNorm*(2*Math.PI),_vec.p_dv);
            _vec.du.subVectors(_vec.p_du,_vec.p).normalize();
            _vec.dv.subVectors(_vec.p_dv,_vec.p).normalize();
            target.crossVectors(_vec.du,_vec.dv).normalize();
            return target;
        };

        // Initialize ant position and compute home positions (like sphere implementation)
        // Start at initial parameters
        const u_init = 0;
        const v_init = 0;
        computeKleinBottlePoint(u_init, v_init, _vec.p);
        computeSurfaceNormal(u_init, v_init, _vec.N);
        computeKleinBottlePoint(u_init + epsilon * (2*Math.PI), v_init, _vec.p_du);
        _vec.F.subVectors(_vec.p_du, _vec.p).normalize().multiplyScalar(-1);

        // Position ant
        _vec.antOffsetPos.copy(_vec.p).addScaledVector(_vec.N, BODY_OFFSET);
        antGroup.position.copy(_vec.antOffsetPos);
        _vec.lookAtTarget.copy(_vec.antOffsetPos).add(_vec.F);
        tempMatrix.lookAt(_vec.antOffsetPos, _vec.lookAtTarget, _vec.N);
        antGroup.quaternion.setFromRotationMatrix(tempMatrix);

        // Update matrices so FK works correctly
        antGroup.updateMatrixWorld(true);
        thorax.updateMatrixWorld(true);

        // Calculate home positions from neutral FK (like sphere)
        const home = (() => {
            const worldToThoraxMat = new THREE.Matrix4().copy(thorax.matrixWorld).invert();
            return legs.map((leg) => {
                // Get tibia tip in world at current neutral rotations
                const tipLocal = new THREE.Vector3(TIBIA_LENGTH, 0, 0);
                const tipWorld = tipLocal.clone();
                leg.tibiaPivot.localToWorld(tipWorld);

                // Convert to thorax local space
                return tipWorld.applyMatrix4(worldToThoraxMat);
            });
        })();

        console.log('=== Home Positions (thorax space) ===');
        home.forEach((h, i) => {
            console.log(`Leg ${i}:`, h.clone());
        });

        function animate(time) {
            requestAnimationFrame(animate);
            controls.update();
            FRAME_NO++;

            // Use actual time like sphere implementation
            const t = performance.now()/1000 - t0;

            // Move body along Klein bottle surface
            // Use time-based movement like sphere
            const pathSpeed = bodySpeed * 0.5; // Adjust for Klein bottle scale
            const u_body = (t * pathSpeed) % (2 * Math.PI);
            const v_body = (t * pathSpeed * 0.3) % (2 * Math.PI); // Slower v movement for interesting path
            
            computeKleinBottlePoint(u_body, v_body, _vec.p);
            computeSurfaceNormal(u_body, v_body, _vec.N);
            computeKleinBottlePoint(u_body + epsilon * (2*Math.PI), v_body, _vec.p_du);
            _vec.F.subVectors(_vec.p_du, _vec.p).normalize().multiplyScalar(-1);

            // Position ant at correct height above surface for legs to reach
            _vec.antOffsetPos.copy(_vec.p).addScaledVector(_vec.N, BODY_OFFSET);
            antGroup.position.copy(_vec.antOffsetPos);
            _vec.lookAtTarget.copy(_vec.antOffsetPos).add(_vec.F);
            tempMatrix.lookAt(_vec.antOffsetPos, _vec.lookAtTarget, _vec.N);
            antGroup.quaternion.setFromRotationMatrix(tempMatrix);
            
            // No body animations - sphere implementation doesn't have these

            thorax.updateMatrixWorld(true);
            worldToLocalMatrix.copy(thorax.matrixWorld).invert();

            legs.forEach((leg, legIndex) => {
                // Use milliseconds and match sphere's period
                const phase = ((t * 1000) / period + leg.phaseOffset) % 1;
                const inStance = phase < 0.5;

                // Start with home position in thorax space (like sphere)
                _vec.targetInThorax.copy(home[legIndex]);

                // Add step offset for walking motion along body +Z
                const stepOffsetThorax = (inStance ? -1 : 1) * (STEP_LENGTH *
                    (inStance ? (phase/0.5) : ((phase-0.5)/0.5)) - STEP_LENGTH/2);
                _vec.targetInThorax.z += stepOffsetThorax;

                // Transform to world space
                _vec.targetWorld = _vec.targetInThorax.clone();
                _vec.targetWorld.applyMatrix4(thorax.matrixWorld);

                // Project target onto Klein bottle surface using tangent-space approximation
                // This respects the IK-calculated foot target position
                const eps_u = 0.01; // Parameter space step for numerical derivative
                const eps_v = 0.01;
                computeKleinBottlePoint(u_body, v_body, _vec.p); // Body position on surface
                computeKleinBottlePoint(u_body + eps_u, v_body, _vec.p_du);
                computeKleinBottlePoint(u_body, v_body + eps_v, _vec.p_dv);

                // Tangent vectors: world space displacement per unit parameter change
                _vec.du.subVectors(_vec.p_du, _vec.p); // du/dε_u
                _vec.dv.subVectors(_vec.p_dv, _vec.p); // dv/dε_v

                // World space offset from body to desired foot target
                _vec.temp1.subVectors(_vec.targetWorld, _vec.p);

                // Project onto tangent basis: find (α, β) such that target ≈ p + α·du + β·dv
                // This gives α and β in units of the epsilon steps
                const alpha = _vec.temp1.dot(_vec.du) / _vec.du.lengthSq();
                const beta = _vec.temp1.dot(_vec.dv) / _vec.dv.lengthSq();

                // Calculate foot position in parameter space
                const u_foot = u_body + alpha * eps_u;
                const v_foot = v_body + beta * eps_v;

                // Debug on first frame
                if (FRAME_NO === 1 && legIndex === 0) {
                    console.log('=== Tangent Space Projection Debug (Leg 0) ===');
                    console.log('Body (u,v):', u_body, v_body);
                    console.log('Body surface pos:', _vec.p.clone());
                    console.log('Target world pos:', _vec.targetWorld.clone());
                    console.log('Offset (target - body):', _vec.temp1.clone());
                    console.log('Tangent du:', _vec.du.clone(), 'length:', _vec.du.length());
                    console.log('Tangent dv:', _vec.dv.clone(), 'length:', _vec.dv.length());
                    console.log('Projection (alpha, beta):', alpha, beta);
                    console.log('Foot (u,v):', u_foot, v_foot);
                    console.log('Foot surface pos:', _vec.footTargetSurface.clone());
                }

                // Get actual surface point and normal
                computeKleinBottlePoint(u_foot, v_foot, _vec.footTargetSurface);
                computeSurfaceNormal(u_foot, v_foot, _vec.normalAtFootTarget);  

                // Smooth normal vector handling
                _vec.correctedFootNormal.copy(_vec.normalAtFootTarget);
                if (_vec.correctedFootNormal.dot(_vec.N) < 0) {
                    _vec.correctedFootNormal.negate();
                }
                
                const normalBlendFactor = 0.15;
                if (leg.lastNormal) {
                    _vec.correctedFootNormal.lerp(leg.lastNormal, 1 - normalBlendFactor);
                }
                leg.lastNormal = leg.lastNormal || new THREE.Vector3();
                leg.lastNormal.copy(_vec.correctedFootNormal);

                // Ensure foot is exactly on the surface
                const actualFootPlantTarget = _vec.footTargetSurface.clone().addScaledVector(_vec.correctedFootNormal, FOOT_SURFACE_OFFSET);

                const wasPlanted = leg.lastPhase < 0.5;
                const isPlanted = phase < 0.5;
                const justStartedSwing = wasPlanted && !isPlanted;
                
                if (justStartedSwing) {
                    leg.swingStartPos.copy(leg.currentTarget);
                }

                if (!leg.initialized) {
                    leg.plantedT.copy(actualFootPlantTarget);
                    leg.currentTarget.copy(actualFootPlantTarget);
                    leg.swingStartPos.copy(actualFootPlantTarget);
                    leg.initialized = true;
                    
                    // Initialize leg angles for standing position - removed as sphere doesn't have this
                }

                if (phase < 0.5) { 
                    _vec.finalFootTargetWorld.copy(leg.plantedT);
                } else { 
                    const swingNormalized = (phase - 0.5) * 2;
                    
                    const easedSwing = swingNormalized < 0.5 
                        ? 2 * swingNormalized * swingNormalized 
                        : 1 - Math.pow(-2 * swingNormalized + 2, 2) / 2;
                    
                    const liftHeight = STEP_HEIGHT * Math.sin(Math.PI * easedSwing);
                    
                    _vec.swingLerpBase.copy(leg.swingStartPos).lerp(actualFootPlantTarget, easedSwing);
                    _vec.finalFootTargetWorld.copy(_vec.swingLerpBase).addScaledVector(_vec.correctedFootNormal, liftHeight);
                    
                    if (swingNormalized >= 0.95) { 
                        leg.plantedT.copy(actualFootPlantTarget); 
                    }
                }
                
                if (!leg.currentTarget.x && !leg.currentTarget.y && !leg.currentTarget.z) {
                    leg.currentTarget.copy(_vec.finalFootTargetWorld);
                }
                leg.currentTarget.lerp(_vec.finalFootTargetWorld, 0.25);

                // Place debug marker at current target
                footMarkers[legIndex].position.copy(leg.currentTarget);
                
                leg.lastPhase = phase;
                
                _vec.targetInThorax.copy(leg.currentTarget).applyMatrix4(worldToLocalMatrix);
                _vec.targetRelToLegRoot.subVectors(_vec.targetInThorax, leg.legRoot.position);

                // Solve yaw s.t. planted lies in coxa local XY plane (z≈0), then do IK in coxa local
                // First pass: compute coxa local point and yaw correction to zero z
                const computeWorldToCoxa = () => new THREE.Matrix4().copy(leg.coxaPivot.matrixWorld).invert();
                let worldToCoxa = computeWorldToCoxa();
                let pCoxa = leg.currentTarget.clone().applyMatrix4(worldToCoxa); // in coxa local
                const dYaw = Math.atan2(pCoxa.z, pCoxa.x);
                leg.legRoot.rotation.y -= dYaw; // rotate so z→0
                leg.legRoot.updateMatrixWorld(true);
                // Recompute with corrected yaw
                worldToCoxa = computeWorldToCoxa();
                pCoxa = leg.currentTarget.clone().applyMatrix4(worldToCoxa);
                // Planar IK in coxa local XY
                const xLeg = pCoxa.x - COXA_LENGTH;
                const yLeg = pCoxa.y; 

                // IK solver in XY plane (after yaw unrotation and coxa splay removal)
                function solvePlanarIK(x, y) {
                    const L1 = FEMUR_LENGTH, L2 = TIBIA_LENGTH;
                    const D = Math.max(1e-6, Math.min(L1 + L2 - 1e-4, Math.hypot(x, y)));
                    const cosKnee = THREE.MathUtils.clamp((L1*L1 + L2*L2 - D*D) / (2*L1*L2), -1, 1);
                    // Mechanical knee rotation (0 straight → pi folded); matches our rig's tibiaPivot rotation
                    const knee = Math.PI - Math.acos(cosKnee);
                    const femur = Math.atan2(y, x) - Math.atan2(L2 * Math.sin(knee), L1 + L2 * Math.cos(knee));
                    return { femur, tibia: knee };
                }

                // If stance target is barely reachable, trigger swing early to avoid sliding
                // inStance already declared above
                if (inStance) {
                    const L1 = FEMUR_LENGTH, L2 = TIBIA_LENGTH;
                    const D = Math.hypot(xLeg, yLeg);
                    const MAX_REACH = L1 + L2 - 1e-3;
                    if (D > MAX_REACH * 0.985) {
                        // Would trigger early swing, but keeping for now
                    }
                }

                let femurAngle, tibiaAngle;
                if (inStance) {
                    // Exact IK in stance so the tibia tip touches ground
                    const res = solvePlanarIK(xLeg, yLeg);
                    femurAngle = THREE.MathUtils.clamp(res.femur, -1.6, 0.2);
                    tibiaAngle = THREE.MathUtils.clamp(res.tibia, 0.0, 2.6);
                } else {
                    // During swing, keep tibia near neutral and use femur to lift/place for stability
                    const TIBIA_NEUTRAL = 0.8;
                    const L1 = FEMUR_LENGTH, L2 = TIBIA_LENGTH;
                    const Dfixed = Math.sqrt(L1*L1 + L2*L2 + 2*L1*L2*Math.cos(TIBIA_NEUTRAL));
                    const r = Math.hypot(xLeg, yLeg) || 1e-6;
                    const scale = Dfixed / r;
                    const xFixed = xLeg * scale;
                    const yFixed = yLeg * scale;
                    const phi = Math.atan2(yFixed, xFixed);
                    const Aangle = Math.atan2(L2*Math.sin(TIBIA_NEUTRAL), L1 + L2*Math.cos(TIBIA_NEUTRAL));
                    femurAngle = phi - Aangle;
                    femurAngle = THREE.MathUtils.clamp(femurAngle, -1.6, 0.2);
                    tibiaAngle = TIBIA_NEUTRAL;
                }

                // Apply rotations directly (sphere doesn't do smoothing here)
                leg.femurPivot.rotation.z = femurAngle;
                leg.tibiaPivot.rotation.z = tibiaAngle;

                // Update marker to show actual foot tip (FK) to verify contact
                thorax.updateMatrixWorld(true);
                const tipLocal = new THREE.Vector3(TIBIA_LENGTH, 0, 0);
                const tipWorld = tipLocal.clone();
                leg.tibiaPivot.localToWorld(tipWorld);
                footMarkers[legIndex].position.copy(tipWorld);

                // Log foot positions periodically
                if (LOG_WALK && FRAME_NO === 1) {
                    // Calculate actual foot tip position
                    leg.tibiaPivot.updateMatrixWorld(true);
                    const tipLocal = new THREE.Vector3(TIBIA_LENGTH, 0, 0); // X-axis aligned
                    const tipWorld = tipLocal.clone();
                    leg.tibiaPivot.localToWorld(tipWorld);

                    // Calculate distance from foot to surface
                    const footToSurface = tipWorld.distanceTo(_vec.footTargetSurface);

                    console.log(`Leg ${legs.indexOf(leg)}: side=${leg.side}`);
                    console.log(`  Target surface:`, _vec.footTargetSurface.clone());
                    console.log(`  Actual foot pos:`, tipWorld.clone());
                    console.log(`  Distance to surface:`, footToSurface);
                }
            });

            // Log body distance on first frame
            if (FRAME_NO === 1) {
                console.log('=== Body Position at frame 1 ===');
                console.log('Body position:', antGroup.position.clone());
                console.log('Surface point:', _vec.p.clone());
                console.log('Surface normal:', _vec.N.clone());
                console.log('Distance from surface:', BODY_OFFSET);
            }

            // Periodic detailed logging during stance
            if (LOG_WALK && (FRAME_NO % LOG_EVERY === 0)) {
                legs.forEach((leg, i) => {
                    const phase = ((t * 1000) / period + leg.phaseOffset) % 1;
                    if (phase < 0.5) { // Only log during stance
                        leg.tibiaPivot.updateMatrixWorld(true);
                        const tipLocal = new THREE.Vector3(TIBIA_LENGTH, 0, 0); // X-axis aligned
                        const tipWorld = tipLocal.clone();
                        leg.tibiaPivot.localToWorld(tipWorld);

                        const delta = tipWorld.clone().sub(leg.plantedT);
                        console.log(JSON.stringify({
                            frame: FRAME_NO,
                            legIndex: i,
                            side: leg.side,
                            planted: { x: +leg.plantedT.x.toFixed(4), y: +leg.plantedT.y.toFixed(4), z: +leg.plantedT.z.toFixed(4) },
                            tipWorld: { x: +tipWorld.x.toFixed(4), y: +tipWorld.y.toFixed(4), z: +tipWorld.z.toFixed(4) },
                            delta: { x: +delta.x.toFixed(4), y: +delta.y.toFixed(4), z: +delta.z.toFixed(4) }
                        }));
                    }
                });
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; 
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate(0);
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heap's Algorithm</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <article>
        <header>
            <h1>Heap's Algorithm</h1>
            <p class="subtitle">Generating all permutations with minimal swaps</p>
        </header>

        <section id="intro">
            <p>
                How do you generate every possible arrangement of a set of elements?
                The naive approach copies and rearranges repeatedly. But there's a beautiful
                algorithm discovered by B.R. Heap in 1963 that does something remarkable:
                it generates each new permutation by swapping just <em>two elements</em>.
            </p>

            <p>
                This means to generate all 24 permutations of [A,B,C,D], Heap's algorithm
                performs exactly 23 swaps. One swap, one new arrangement. No wasted motion.
            </p>
        </section>

        <section id="simple-case">
            <h2>Start Simple: Two Elements</h2>

            <p>With just two elements, there are only two permutations:</p>

            <div class="swap-demo" id="demo-2">
                <div class="demo-row">
                    <div class="perm-box">[A, B]</div>
                    <div class="swap-arrow">swap 0↔1</div>
                    <div class="perm-box">[B, A]</div>
                </div>
            </div>

            <p>One swap. Done. Now let's add a third element.</p>
        </section>

        <section id="three-elements">
            <h2>Three Elements: The Pattern Emerges</h2>

            <p>
                With three elements, we have 3! = 6 permutations. Watch what Heap's algorithm does:
            </p>

            <div class="interactive-demo" id="demo-3">
                <div class="demo-controls">
                    <button id="play-3" class="btn">▶ Play</button>
                    <button id="step-3" class="btn">Step</button>
                    <button id="reset-3" class="btn">Reset</button>
                </div>

                <div class="demo-stage">
                    <div class="current-state">
                        <div class="element" data-idx="0">A</div>
                        <div class="element" data-idx="1">B</div>
                        <div class="element" data-idx="2">C</div>
                    </div>
                    <div class="swap-info" id="swap-info-3">Click Play or Step</div>
                </div>

                <div class="permutation-trail" id="trail-3">
                    <div class="trail-item active">ABC</div>
                </div>
            </div>

            <p>
                Notice the pattern: we generate all permutations where C is in the last position,
                then swap to put a different element there, and repeat.
            </p>
        </section>

        <section id="the-insight">
            <h2>The Key Insight</h2>

            <p>
                Heap's algorithm is recursive. To permute n elements:
            </p>

            <ol class="insight-list">
                <li>Generate all permutations of the first n-1 elements (keeping the last element fixed)</li>
                <li>Swap to bring a new element into the last position</li>
                <li>Repeat until every element has had a turn in the last position</li>
            </ol>

            <div class="visual-recursion">
                <div class="recursion-level">
                    <div class="level-label">Permute 3 elements:</div>
                    <div class="level-content">
                        <div class="sub-problem">
                            <span class="bracket">[</span>
                            <span class="varying">permute A,B</span>
                            <span class="bracket">]</span>
                            <span class="fixed">C</span>
                        </div>
                        <div class="then">→ swap →</div>
                        <div class="sub-problem">
                            <span class="bracket">[</span>
                            <span class="varying">permute B,C</span>
                            <span class="bracket">]</span>
                            <span class="fixed">A</span>
                        </div>
                        <div class="then">→ swap →</div>
                        <div class="sub-problem">
                            <span class="bracket">[</span>
                            <span class="varying">permute C,A</span>
                            <span class="bracket">]</span>
                            <span class="fixed">B</span>
                        </div>
                    </div>
                </div>
            </div>

            <p>
                But here's the puzzle: <em>which</em> element should we swap into the last position each time?
            </p>
        </section>

        <section id="the-rule">
            <h2>The Parity Rule</h2>

            <p>
                This is where Heap's genius shows. The swap rule depends on whether n is even or odd:
            </p>

            <div class="rule-comparison">
                <div class="rule-box odd">
                    <h3>When n is odd</h3>
                    <div class="rule-visual">
                        <div class="array-viz">
                            <span class="el swap-source">0</span>
                            <span class="el">1</span>
                            <span class="el">2</span>
                            <span class="el swap-target">n-1</span>
                        </div>
                        <div class="rule-desc">Always swap first element with last</div>
                    </div>
                </div>
                <div class="rule-box even">
                    <h3>When n is even</h3>
                    <div class="rule-visual">
                        <div class="array-viz">
                            <span class="el swap-source">i</span>
                            <span class="el">...</span>
                            <span class="el swap-target">n-1</span>
                        </div>
                        <div class="rule-desc">Swap position i with last (i goes 0, 1, 2, ...)</div>
                    </div>
                </div>
            </div>

            <p>
                Why these specific rules? They're not arbitrary—they're the <em>only</em> rules that work.
            </p>
        </section>

        <section id="why-parity">
            <h2>Why Parity Matters</h2>

            <p>
                Think of nested gears in a clock. If two adjacent gears spin the same direction,
                they grind. They must spin <em>opposite</em> directions to mesh properly.
            </p>

            <div class="gear-demo">
                <div class="gear-pair">
                    <div class="gear outer">n even<br><small>rotates through positions</small></div>
                    <div class="meshing">⚙</div>
                    <div class="gear inner">n-1 odd<br><small>pivots on position 0</small></div>
                </div>
            </div>

            <p>
                The same principle applies here. After the recursive call returns, the first n-1
                elements are in a specific state that depends on parity:
            </p>

            <div class="state-table">
                <div class="state-row header">
                    <span>After permuting n-1 elements...</span>
                    <span>So the outer level must...</span>
                </div>
                <div class="state-row">
                    <span><strong>If n-1 is odd:</strong> elements return to ~original order</span>
                    <span>Rotate through positions to create new combinations</span>
                </div>
                <div class="state-row">
                    <span><strong>If n-1 is even:</strong> elements end up shuffled differently</span>
                    <span>Use fixed position (inner provides the variation)</span>
                </div>
            </div>

            <div class="key-insight">
                <p>
                    <strong>The one-liner:</strong> When inside rotates, outside pivots.
                    When inside pivots, outside rotates.
                </p>
            </div>
        </section>

        <section id="four-elements">
            <h2>Four Elements: See It All Together</h2>

            <p>
                Now watch the full algorithm on four elements. Notice how the parity rule
                creates a meshing pattern between levels:
            </p>

            <div class="interactive-demo large" id="demo-4">
                <div class="demo-controls">
                    <button id="play-4" class="btn">▶ Play</button>
                    <button id="step-4" class="btn">Step</button>
                    <button id="reset-4" class="btn">Reset</button>
                    <div class="speed-control">
                        <label>Speed:</label>
                        <input type="range" id="speed-4" min="100" max="1000" value="400">
                    </div>
                </div>

                <div class="demo-stage">
                    <div class="current-state" id="state-4">
                        <div class="element" data-idx="0">A</div>
                        <div class="element" data-idx="1">B</div>
                        <div class="element" data-idx="2">C</div>
                        <div class="element" data-idx="3">D</div>
                    </div>
                    <div class="swap-info" id="swap-info-4">Click Play or Step</div>
                    <div class="level-indicator" id="level-4">
                        <span class="level-badge">k=4</span>
                    </div>
                </div>

                <div class="permutation-grid" id="trail-4">
                    <div class="trail-item active">ABCD</div>
                </div>

                <div class="stats" id="stats-4">
                    <span>Permutations: <strong id="perm-count-4">1</strong>/24</span>
                    <span>Swaps: <strong id="swap-count-4">0</strong></span>
                </div>
            </div>
        </section>

        <section id="the-code">
            <h2>The Code</h2>

            <p>The entire algorithm in just a few lines:</p>

            <pre><code>function heapPermute(arr, n = arr.length) {
    if (n === 1) {
        output(arr);
        return;
    }

    for (let i = 0; i < n; i++) {
        heapPermute(arr, n - 1);

        if (i < n - 1) {  // don't swap after last iteration
            if (n % 2 === 0) {
                swap(arr, i, n - 1);
            } else {
                swap(arr, 0, n - 1);
            }
        }
    }
}</code></pre>

            <p>
                That's it. The parity check <code>n % 2 === 0</code> is the entire secret.
                Everything else is just recursion and a loop.
            </p>
        </section>

        <section id="why-it-matters">
            <h2>Why This Matters</h2>

            <p>
                Heap's algorithm achieves the theoretical minimum: n! - 1 swaps for n! permutations.
                Each swap produces exactly one new arrangement. This makes it:
            </p>

            <ul>
                <li><strong>Cache-friendly:</strong> Only two elements move at a time</li>
                <li><strong>Minimal memory:</strong> Works in-place, no copying needed</li>
                <li><strong>Simple to implement:</strong> Just recursion + parity check</li>
            </ul>

            <p>
                The deeper lesson: sometimes the right abstraction makes a complex problem trivial.
                Heap found that parity—the simplest property of numbers—perfectly captures
                what's needed to navigate the space of permutations.
            </p>
        </section>

        <footer>
            <p>
                An interactive exploration of Heap's Algorithm.
                <a href="https://en.wikipedia.org/wiki/Heap%27s_algorithm">Learn more →</a>
            </p>
        </footer>
    </article>

    <script src="script.js"></script>
</body>
</html>
